import { SessionValidationError, SessionValidationErrorCode } from '@session.js/errors';
import ByteBuffer from 'bytebuffer';
// ðŸ‘‡ Credit: https://stackoverflow.com/a/69585881 ðŸ‘‡
const HEX_STRINGS = '0123456789abcdef';
const MAP_HEX = {
    0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6,
    7: 7, 8: 8, 9: 9, a: 10, b: 11, c: 12, d: 13,
    e: 14, f: 15, A: 10, B: 11, C: 12, D: 13,
    E: 14, F: 15
};
export function Uint8ArrayToHex(bytes) {
    return Array.from(bytes || [])
        .map((b) => HEX_STRINGS[b >> 4] + HEX_STRINGS[b & 15])
        .join('');
}
export function hexToUint8Array(hexString) {
    const bytes = new Uint8Array(Math.floor((hexString || '').length / 2));
    let i;
    for (i = 0; i < bytes.length; i++) {
        const a = MAP_HEX[hexString[i * 2]];
        const b = MAP_HEX[hexString[i * 2 + 1]];
        if (a === undefined || b === undefined) {
            break;
        }
        bytes[i] = (a << 4) | b;
    }
    return i === bytes.length ? bytes : bytes.slice(0, i);
}
// ðŸ‘† Credit: https://stackoverflow.com/a/69585881 ðŸ‘†
export const concatUInt8Array = (...args) => {
    const totalLength = args.reduce((acc, current) => acc + current.length, 0);
    const concatted = new Uint8Array(totalLength);
    let currentIndex = 0;
    args.forEach(arr => {
        concatted.set(arr, currentIndex);
        currentIndex += arr.length;
    });
    return concatted;
};
export function removePrefixIfNeeded(input) {
    if (typeof input === 'string' && input.startsWith('05')) {
        return input.slice(2);
    }
    else if (input instanceof Uint8Array && input[0] === 5) {
        return input.slice(1);
    }
    return input;
}
export const isHex = (str) => {
    return /^([0-9a-f]{2})+$/i.test(str);
};
export function Uint8ArrayToBase64(uint8array) {
    return ByteBuffer.wrap(uint8array).toString('base64');
}
export function base64ToUint8Array(string) {
    return new Uint8Array(ByteBuffer.wrap(string, 'base64').toArrayBuffer());
}
export class Deferred {
    promise;
    resolve;
    reject;
    constructor() {
        this.promise = new Promise((resolve, reject) => {
            this.resolve = resolve;
            this.reject = reject;
        });
    }
}
export function checkStorage(storage) {
    if (typeof storage !== 'object' || storage === null) {
        throw new SessionValidationError({ code: SessionValidationErrorCode.InvalidOptions, message: 'Provided storage is invalid' });
    }
    const storageObj = storage;
    ['get', 'set', 'delete', 'has'].forEach((method) => {
        if (!(method in storageObj) || typeof storageObj[method] !== 'function') {
            throw new SessionValidationError({ code: SessionValidationErrorCode.InvalidOptions, message: `Provided storage does not have method ${method}` });
        }
    });
}
export function checkNetwork(network) {
    if (typeof network !== 'object' || network === null) {
        throw new SessionValidationError({ code: SessionValidationErrorCode.InvalidOptions, message: 'Provided network is invalid' });
    }
    const storageObj = network;
    ['onRequest'].forEach((method) => {
        if (!(method in storageObj) || typeof storageObj[method] !== 'function') {
            throw new SessionValidationError({ code: SessionValidationErrorCode.InvalidOptions, message: `Provided network does not have method ${method}` });
        }
    });
}
export function getPlaceholderDisplayName(sessionID) {
    return `(${sessionID.slice(0, 4)}...${sessionID.slice(-4)})`;
}
