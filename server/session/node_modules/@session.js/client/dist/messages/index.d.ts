import { SignalService } from '@session.js/types/signal-bindings';
import type { EnvelopePlus } from '@session.js/types/envelope';
import { type Profile } from '../profile/index.js';
export type PrivateMessage = {
    type: 'private';
};
export type ClosedGroupMessage = {
    type: 'group';
    groupId: string;
};
export type MessageAttachment = {
    id: string;
    caption?: string;
    metadata: {
        width?: number;
        height?: number;
        contentType?: string;
    };
    /** Size of attached file in bytes */
    size?: number;
    /** Filename including extension */
    name?: string;
    /** For internal decryption purposes */
    _key?: Uint8Array;
    /** For internal decryption purposes */
    _digest?: Uint8Array;
};
export type Message = (PrivateMessage | ClosedGroupMessage) & {
    id: string;
    from: string;
    author: Profile;
    text?: string;
    attachments: MessageAttachment[];
    replyToMessage?: {
        timestamp: number;
        author: string;
        text?: string;
        attachments?: QuotedAttachment[];
    };
    timestamp: number;
    getEnvelope: () => EnvelopePlus;
    getContent: () => SignalService.Content;
    getReplyToMessage: () => Message['replyToMessage'];
};
export type SyncMessage = Omit<Message, 'from'> & {
    to: string;
};
export type QuotedAttachment = {
    contentType?: string;
    fileName?: string;
};
type Content = {
    hash: string;
    envelope: EnvelopePlus;
    content: SignalService.Content;
};
export declare function mapDataMessage({ hash, envelope, content }: Content): Message;
export declare function parseAttachments(attachments: SignalService.IAttachmentPointer[]): Message['attachments'];
export declare function parseQuote(quote: SignalService.DataMessage.IQuote): Message['replyToMessage'];
export type MessageDeleted = {
    /** Timestamp of deleted message sent in that message constructor. Lookup message by timestamp in saved messages */
    timestamp: number;
    /** Sender of message that deleted it */
    from: string;
};
export declare function mapUnsendMessage({ content }: Content): MessageDeleted;
export type MessageReadEvent = {
    /** Timestamp of read message sent in this message constructor. Lookup message by timestamp among locally saved messages */
    timestamp: number;
    /** Timestamp when recipient of message read it */
    /** Session ID of conversation where message was read */
    conversation: string;
};
export declare function mapReceiptMessage({ content, envelope }: Content): MessageReadEvent[];
export type MessageTypingIndicator = {
    /** If true, you should countdown from 20 and then treat it like recipient stopped typing */
    isTyping: boolean;
    /** Session ID of conversation where typing indicator appeared or disappeared */
    conversation: string;
};
export declare function mapTypingMessage({ content, envelope }: Content): MessageTypingIndicator;
export type ScreenshotTakenNotification = {
    /** Timestamp when screenshot was taken */
    timestamp: number;
    /** Session ID of conversation where notification appeared */
    conversation: string;
};
export declare function mapScreenshotTakenMessage({ content, envelope }: Content): ScreenshotTakenNotification;
export type MediaSavedNotification = {
    /** Message's timestamp which has attachment that was downloaded */
    timestamp: number;
    /** Session ID of conversation where notification appeared */
    conversation: string;
};
export declare function mapMediaSavedMessage({ content, envelope }: Content): MediaSavedNotification;
export type MessageRequestResponse = {
    profile: Profile;
    conversation: string;
};
export declare function mapMessageRequestResponseMessage({ content, envelope }: Content): MessageRequestResponse;
export type CallMessage = {
    uuid: string;
    type: SignalService.CallMessage.Type;
    from: string;
};
export declare function mapCallMessage({ content, envelope }: Content): CallMessage;
export type ReactionMessage = {
    messageTimestamp: number;
    messageAuthor: string;
    reactionFrom: string;
    /** Emoji as string. Any unicode character(s) may be in this field, length is practically unlimited, validation is not performed by the @session.js/client library. You should probably only display the reaction, if it's a single valid emoji */
    emoji: string;
};
export declare function mapReactionMessage({ content, envelope }: Content): ReactionMessage | null;
export {};
