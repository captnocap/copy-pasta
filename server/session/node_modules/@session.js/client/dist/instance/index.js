import { checkStorage, checkNetwork, getPlaceholderDisplayName } from '../utils.js';
import { SessionRuntimeError, SessionRuntimeErrorCode } from '@session.js/errors';
import { InMemoryStorage } from '../storage/index.js';
import { bunNetworkModule } from '../initializers/index.js';
import { RequestType } from '@session.js/types/network/request';
import { getMnemonic, setMnemonic } from './get-set-mnemomic.js';
import { sendMessage } from './send-message.js';
import { blindSessionId, encodeSogsMessage, signSogsRequest, sendSogsRequest } from './sogs.js';
import { getOurSwarm, getSwarmsFor } from './swarms.js';
import { addPoller } from './polling.js';
import { getSnodes } from './snodes.js';
import { getFile } from './get-file.js';
import { deleteMessage, deleteMessages } from './delete-message.js';
import { markMessagesAsRead } from './mark-message-as-read.js';
import { showTypingIndicator, hideTypingIndicator } from './typing-indicator.js';
import { notifyScreenshotTaken, notifyMediaSaved } from './data-extraction-notification.js';
import { acceptConversationRequest } from './accept-conversation-request.js';
import { setAvatar } from './set-avatar.js';
import { setDisplayName } from './display-name.js';
import { addReaction, removeReaction } from './reactions.js';
import { _storeMessage } from './store-message.js';
import { downloadAvatar } from '../profile/index.js';
export class Session {
    mnemonic;
    keypair;
    sessionID;
    displayName;
    avatar;
    network;
    storage;
    snodes;
    ourSwarms;
    ourSwarm;
    pollers = new Set();
    isAuthorized = false;
    constructor(options) {
        if (options?.storage) {
            checkStorage(options?.storage);
        }
        if (options?.network) {
            checkNetwork(options.network);
            this.network = options.network;
        }
        else {
            if (typeof Bun !== 'undefined') {
                this.network = new bunNetworkModule.BunNetwork();
            }
            else {
                throw new SessionRuntimeError({ code: SessionRuntimeErrorCode.NetworkNotProvided, message: 'You haven\'t provided @session.js/client compatible network, yet trying to use Session instance outside of Bun runtime. This will not work, you must either run this project with bun.sh or provide compatible Network and other modular instruments. Alternatively, if you just want to use utilities, take a look at packages like @session.js/ons, @session.js/keypair, @session.js/mnemonic and others that @session.js/client uses under the hood and that do not require Bun server runtime.' });
            }
        }
        this.storage = options?.storage ?? new InMemoryStorage();
    }
    async _init() {
        const savedAvatar = await this.storage.get('avatar');
        if (savedAvatar !== null) {
            const { key, url } = JSON.parse(savedAvatar);
            const profileKey = new Uint8Array(key);
            this.avatar = { key: profileKey, url };
        }
    }
    /** Returns mnemonic of this instance or undefined, if you haven't set it with setMnemonic yet */
    getMnemonic = getMnemonic.bind(this);
    /** Sets mnemonic for this instance, parses it to keypair. Throws SessionValidationError if mnemonic is invalid. Make sure you call this method only once, otherwise it will throw SessionRuntimeError */
    setMnemonic = setMnemonic.bind(this);
    /** Returns Session ID of this instance. Throws if you haven't set user with setMnemonic yet */
    getSessionID() {
        if (this.sessionID === undefined)
            throw new SessionRuntimeError({ code: SessionRuntimeErrorCode.EmptyUser, message: 'Instance is not initialized; use setMnemonic first' });
        return this.sessionID;
    }
    /** Get cached display name of this instance. Note that it doesn't fetch display name from network, since display name comes in configuration message, so this method might return undefined */
    getDisplayName() {
        return this.displayName;
    }
    /**
     * Set display name of this instance by saving it locally and to network.
     * All unicode characters are accepted except for `ￒ` (0xffd2) which is reserved by Session for mentions. Max length: 64 characters
     * Might throw SessionFetchError if there is a connection issue
     * */
    setDisplayName = setDisplayName.bind(this);
    /**
     * Get this instance's cached avatar.  Note that it doesn't fetch avatar from network, since avatar comes in a configuration message, so this method might return undefined
     * If you're looking for a way to get other user's avatar, please make yourself familiar with [How Session profiles work](https://sessionjs.github.io/docs/principles/users/#how-session-profiles-work) in the documentation
     * If you're looking for a method to download and decrypt avatar's image, please use downloadAvatar
     */
    getAvatar() {
        return this.avatar;
    }
    /**
     * Set this instance's avatar by uploading it to file server and saving to network. It must be a valid image that can be displayed in most Session clients.
     * Might throw SessionFetchError if there is a connection issue
     */
    setAvatar = setAvatar.bind(this);
    /**
     * Download avatar using URL and key from Profile object. Returns decrypted ArrayBuffer with image data.
     * Might throw SessionFetchError if there is a connection issue
     * Might throw SessionValidationError if avatar's URL is not from Session file server
     * @param avatar Avatar object from Profile's object with `url` and `key` properties
     */
    downloadAvatar = downloadAvatar.bind(this);
    /** Returns Session.keypair of this instance. Returns undefined if you haven't initialized this instance with mnemonic yet. */
    getKeypair() {
        return this.keypair;
    }
    /** Advanced use. Returns current timestamp just like Date.now() but with network connection offset */
    getNowWithNetworkOffset() {
        return Date.now(); // todo: replace with network timestamp
    }
    /** Advanced use. Returns swarms for specified Session ID */
    getSwarmsFor = getSwarmsFor.bind(this);
    /** Advanced use. Returns swarms that store messages for our Session ID */
    getOurSwarm = getOurSwarm.bind(this);
    /** Advanced use. Returns Session nodes list */
    getSnodes = getSnodes.bind(this);
    /** Add Poller class instance to this Session instance to start polling new messages */
    addPoller = addPoller.bind(this);
    /** Download attachment received in message object. Returns File with decrypted content */
    getFile = getFile.bind(this);
    /**
     * Sends a visible chat message to other Session ID
     * Might throw SessionFetchError if there is a connection issue
     * @param to — Session ID of the recipient
     * @param text — Text of the message
     * @param attachments Array of instances of File bytes to send with the message
     * @param voiceMessage — Voice message file to attach to message
     * @param replyToMessage — Reply to specific message
     * @returns `Promise<{ messageHash: string, syncMessageHash: string }>` — hashes (identifiers) of the messages sent (visible and sync message)
     */
    sendMessage = sendMessage.bind(this);
    /**
     * Convert unblinded (prefix 05) Session ID to blinded Session ID (prefix 15)
     * @param serverPk — Server's public key in hex format
     * @returns `Promise<string>` — blinded Session ID
     */
    blindSessionId = blindSessionId.bind(this);
    /**
     * Encodes SOGS message to store on SOGS
     * @param serverPk — Server's public key in hex format
     * @param text — Text of the message
     * @param attachments — Array of AttachmentPointerWithUrl of attachments uploaded to SOGS
     * @param replyToMessage — Array of AttachmentPointerWithUrl of attachments uploaded to SOGS
     * @param blind — Whether to encrypt this message to be sent as blinded user or not
     * @returns `Promise<{ data: string, signature: string }>` — message data and signature
     */
    encodeSogsMessage = encodeSogsMessage.bind(this);
    /**
     * Sign request to SOGS (`sendSogsRequest` is recommended instead)
     * @param blind — Whether to sign this request to be sent as blinded user or not
     * @param serverPk — Server's public key in hex format
     * @param timestamp — Timestamp (in unix seconds) that you will pass in `X-SOGS-Timestamp` header
     * @param endpoint — Endpoint of the request with leading slash, e.g. `/room/mytestroom`
     * @param nonce — Random 16 bytes nonce that you will pass in `X-SOGS-Nonce` header
     * @param method — HTTP method of the request e.g. `POST`
     * @param body — Stringified or raw body of request (optional)
     * @returns `Promise<{ data: string, signature: string }>` — message data and signature
     */
    signSogsRequest = signSogsRequest.bind(this);
    /**
     * Encrypt, sign and send request to SOGS
     * @param host — SOGS host (e.g. https://sogs.hloth.dev/)
     * @param serverPk — Server's public key in hex format
     * @param endpoint — Endpoint as string, e.g. `/room/bunsogs`
     * @param method — HTTP method of the request e.g. `POST`
     * @param body — Stringified or raw body of request (optional)
     * @param blind — Whether to send this request as blinded user (recommended) or not. Defaults to true
     * @returns `Promise<any>` — response from SOGS
     */
    sendSogsRequest = sendSogsRequest.bind(this);
    /**
     * Propogates unsend request which Session clients use to delete messages locally. For performance reasons, choose deleteMessages for batch deletion of multiple messages
     * Might throw SessionFetchError if there is a connection issue
     * @param to Session ID of recipient of the message
     * @param timestamp Timestamp of the message, returned from sendMessage; this is important and **must be exactly what's returned from sendMessage result**, otherwise clients which already received the message won't be able to delete it
     * @param hash Saved messageHash identifier of the message to delete, returned from sendMessage
     */
    deleteMessage = deleteMessage.bind(this);
    /**
     * Propogates unsend requests which Session clients use to delete messages locally. Alternatively, use deleteMessage for single message deletion
     * Might throw SessionFetchError if there is a connection issue
     * @param to Session ID of recipient of the message
     * @param timestamp Timestamp of the message, returned from sendMessage; this is important and **must be exactly what's returned from sendMessage result**, otherwise clients which already received the message won't be able to delete it
     * @param hashes Saved messages hashes identifiers of the message to delete, returned from sendMessage's messageHash
     */
    deleteMessages = deleteMessages.bind(this);
    /**
     * Mark message as read and broadcast it to recipient
     * Might throw SessionFetchError if there is a connection issue
     * @param from Session ID of sender of the message
     * @param messagesTimestamps Array of timestamps of the messages to mark as read, returned from message constructor
     * @param readAt Timestamp when recipient of the message read it, defaults to current time. Does not seem to be used in current Session implementations
     */
    markMessagesAsRead = markMessagesAsRead.bind(this);
    /**
     * Show message typing indicator to recipient for 20 seconds or until hideTypingIndicator is called
     * Might throw SessionFetchError if there is a connection issue
     * @param conversation Session ID of conversation where typing indicator should appear
     */
    showTypingIndicator = showTypingIndicator.bind(this);
    /**
     * Hide message typing indicator from recipient
     * Might throw SessionFetchError if there is a connection issue
     * @param conversation Session ID of conversation where typing indicator should disappear
     */
    hideTypingIndicator = hideTypingIndicator.bind(this);
    /**
     * Show notification that screenshot was taken in chat and broadcast it to other clients
     * Might throw SessionFetchError if there is a connection issue
     * @param conversation Session ID of conversation where screenshot was taken
     */
    notifyScreenshotTaken = notifyScreenshotTaken.bind(this);
    /**
     * Show notification that attachment was downloaded in chat and broadcast it to other clients
     * Might throw SessionFetchError if there is a connection issue
     * @param conversation Session ID of conversation where attachment was downloaded
     * @param savedMessageTimestamp Timestamp of the message with attachment, returned from sendMessage
     */
    notifyMediaSaved = notifyMediaSaved.bind(this);
    /**
     * Accept conversation request from another Session ID
     * Might throw SessionFetchError if there is a connection issue
     * @param from Session ID of the sender of the conversation request
     */
    acceptConversationRequest = acceptConversationRequest.bind(this);
    /**
     * Add emoji reaction to the message
     * Might throw SessionFetchError if there is a connection issue
     * @param messageTimestamp Timestamp of the message to react to, obtained from message object
     * @param messageAuthor Session ID of the author of the message to react to
     * @param emoji Emoji as string to add to reactions list. Any unicode character(s) are accepted, length is practically unlimited, but most clients will only display reaction if it's a single valid emoji.
     */
    addReaction = addReaction.bind(this);
    /**
     * Remove emoji reaction from the message
     * Might throw SessionFetchError if there is a connection issue
     * @param messageTimestamp Timestamp of the message to remove react from, obtained from message object
     * @param messageAuthor Session ID of the author of the message to remove reaction from
     * @param emoji Emoji as string to add to reactions list. Any unicode character(s) are accepted, length is practically unlimited, but most clients will only display reaction if it's a single valid emoji
     */
    removeReaction = removeReaction.bind(this);
    _storeMessage = _storeMessage.bind(this);
    async _request({ type, body }) {
        return await this.network.onRequest(type, body);
    }
    /**
     * Advanced use. Returns profile object with display name and avatar of this instance
     * @returns Profile (for messages classes)
     */
    getMyProfile() {
        return {
            displayName: this.displayName ?? getPlaceholderDisplayName(this.getSessionID()),
            avatar: this.getAvatar(),
        };
    }
    events = new Map();
    on(eventName, callback) {
        this.addEventListener(eventName, callback);
    }
    off(eventName, callback) {
        this.removeEventListener(eventName, callback);
    }
    addEventListener(eventName, callback) {
        this.events.set(eventName, [...(this.events.get(eventName) ?? []), callback]);
    }
    removeEventListener(eventName, callback) {
        this.events.set(eventName, (this.events.get(eventName) ?? []).filter(cb => cb !== callback));
    }
    _emit(eventName, ...args) {
        this.events.get(eventName)?.forEach(cb => {
            cb(...args);
        });
    }
}
