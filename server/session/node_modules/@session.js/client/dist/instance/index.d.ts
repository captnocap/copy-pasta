import type { Storage, Network } from '@session.js/types';
import { RequestType } from '@session.js/types/network/request';
import type { Keypair } from '@session.js/keypair';
import type { Snode } from '@session.js/types/snode';
import type { Swarm } from '@session.js/types/swarm';
import type { Poller } from '../polling/index.js';
import type { EventCallback, EventName } from './events.js';
import { type Profile } from '../profile/index.js';
export declare class Session {
    protected mnemonic: string | undefined;
    protected keypair: Keypair | undefined;
    protected sessionID: string | undefined;
    protected displayName: string | undefined;
    protected avatar: Profile['avatar'];
    protected network: Network;
    protected storage: Storage;
    protected snodes: Snode[] | undefined;
    protected ourSwarms: Swarm[] | undefined;
    protected ourSwarm: Swarm | undefined;
    protected pollers: Set<Poller>;
    isAuthorized: boolean;
    constructor(options?: {
        storage?: Storage;
        network?: Network;
    });
    protected _init(): Promise<void>;
    /** Returns mnemonic of this instance or undefined, if you haven't set it with setMnemonic yet */
    getMnemonic: () => string | undefined;
    /** Sets mnemonic for this instance, parses it to keypair. Throws SessionValidationError if mnemonic is invalid. Make sure you call this method only once, otherwise it will throw SessionRuntimeError */
    setMnemonic: (mnemonic: string, displayName?: string | undefined) => void;
    /** Returns Session ID of this instance. Throws if you haven't set user with setMnemonic yet */
    getSessionID(): string;
    /** Get cached display name of this instance. Note that it doesn't fetch display name from network, since display name comes in configuration message, so this method might return undefined */
    getDisplayName(): string | undefined;
    /**
     * Set display name of this instance by saving it locally and to network.
     * All unicode characters are accepted except for `ￒ` (0xffd2) which is reserved by Session for mentions. Max length: 64 characters
     * Might throw SessionFetchError if there is a connection issue
     * */
    setDisplayName: (displayName: string) => Promise<void>;
    /**
     * Get this instance's cached avatar.  Note that it doesn't fetch avatar from network, since avatar comes in a configuration message, so this method might return undefined
     * If you're looking for a way to get other user's avatar, please make yourself familiar with [How Session profiles work](https://sessionjs.github.io/docs/principles/users/#how-session-profiles-work) in the documentation
     * If you're looking for a method to download and decrypt avatar's image, please use downloadAvatar
     */
    getAvatar(): {
        url: string;
        key: Uint8Array;
    } | undefined;
    /**
     * Set this instance's avatar by uploading it to file server and saving to network. It must be a valid image that can be displayed in most Session clients.
     * Might throw SessionFetchError if there is a connection issue
     */
    setAvatar: (avatar: ArrayBuffer) => Promise<void>;
    /**
     * Download avatar using URL and key from Profile object. Returns decrypted ArrayBuffer with image data.
     * Might throw SessionFetchError if there is a connection issue
     * Might throw SessionValidationError if avatar's URL is not from Session file server
     * @param avatar Avatar object from Profile's object with `url` and `key` properties
     */
    downloadAvatar: (avatar: {
        url: string;
        key: Uint8Array;
    }) => Promise<ArrayBuffer>;
    /** Returns Session.keypair of this instance. Returns undefined if you haven't initialized this instance with mnemonic yet. */
    getKeypair(): Keypair | undefined;
    /** Advanced use. Returns current timestamp just like Date.now() but with network connection offset */
    getNowWithNetworkOffset(): number;
    /** Advanced use. Returns swarms for specified Session ID */
    getSwarmsFor: (sessionID: string) => Promise<Swarm[]>;
    /** Advanced use. Returns swarms that store messages for our Session ID */
    getOurSwarm: () => Promise<Swarm>;
    /** Advanced use. Returns Session nodes list */
    getSnodes: () => Promise<Snode[]>;
    /** Add Poller class instance to this Session instance to start polling new messages */
    addPoller: (poller: Poller) => void;
    /** Download attachment received in message object. Returns File with decrypted content */
    getFile: (attachment: import("../messages/index.js").MessageAttachment) => Promise<File>;
    /**
     * Sends a visible chat message to other Session ID
     * Might throw SessionFetchError if there is a connection issue
     * @param to — Session ID of the recipient
     * @param text — Text of the message
     * @param attachments Array of instances of File bytes to send with the message
     * @param voiceMessage — Voice message file to attach to message
     * @param replyToMessage — Reply to specific message
     * @returns `Promise<{ messageHash: string, syncMessageHash: string }>` — hashes (identifiers) of the messages sent (visible and sync message)
     */
    sendMessage: (args_0: {
        to: string;
        text?: string | undefined;
        attachments?: File[] | undefined;
        voiceMessage?: Blob | undefined;
        replyToMessage?: {
            timestamp: number;
            author: string;
            text?: string | undefined;
            attachments?: {
                contentType?: string | undefined;
                fileName?: string | undefined;
            }[] | undefined;
        } | undefined;
    }) => Promise<{
        messageHash: string;
        syncMessageHash: string;
        timestamp: number;
    }>;
    /**
     * Convert unblinded (prefix 05) Session ID to blinded Session ID (prefix 15)
     * @param serverPk — Server's public key in hex format
     * @returns `Promise<string>` — blinded Session ID
     */
    blindSessionId: (serverPk: string) => string;
    /**
     * Encodes SOGS message to store on SOGS
     * @param serverPk — Server's public key in hex format
     * @param text — Text of the message
     * @param attachments — Array of AttachmentPointerWithUrl of attachments uploaded to SOGS
     * @param replyToMessage — Array of AttachmentPointerWithUrl of attachments uploaded to SOGS
     * @param blind — Whether to encrypt this message to be sent as blinded user or not
     * @returns `Promise<{ data: string, signature: string }>` — message data and signature
     */
    encodeSogsMessage: (args_0: {
        serverPk: string;
        message: import("../messages/schema/index.js").VisibleMessage;
        blind: boolean;
    }) => {
        data: string;
        signature: string;
    };
    /**
     * Sign request to SOGS (`sendSogsRequest` is recommended instead)
     * @param blind — Whether to sign this request to be sent as blinded user or not
     * @param serverPk — Server's public key in hex format
     * @param timestamp — Timestamp (in unix seconds) that you will pass in `X-SOGS-Timestamp` header
     * @param endpoint — Endpoint of the request with leading slash, e.g. `/room/mytestroom`
     * @param nonce — Random 16 bytes nonce that you will pass in `X-SOGS-Nonce` header
     * @param method — HTTP method of the request e.g. `POST`
     * @param body — Stringified or raw body of request (optional)
     * @returns `Promise<{ data: string, signature: string }>` — message data and signature
     */
    signSogsRequest: (args_0: {
        blind: boolean;
        serverPk: string;
        timestamp: number;
        endpoint: string;
        nonce: Uint8Array;
        method: string;
        body?: string | Uint8Array | undefined;
    }) => Promise<Uint8Array>;
    /**
     * Encrypt, sign and send request to SOGS
     * @param host — SOGS host (e.g. https://sogs.hloth.dev/)
     * @param serverPk — Server's public key in hex format
     * @param endpoint — Endpoint as string, e.g. `/room/bunsogs`
     * @param method — HTTP method of the request e.g. `POST`
     * @param body — Stringified or raw body of request (optional)
     * @param blind — Whether to send this request as blinded user (recommended) or not. Defaults to true
     * @returns `Promise<any>` — response from SOGS
     */
    sendSogsRequest: (args_0: {
        host: string;
        serverPk: string;
        endpoint: string;
        method: string;
        body?: string | Uint8Array | undefined;
        blind: boolean;
    }) => Promise<unknown>;
    /**
     * Propogates unsend request which Session clients use to delete messages locally. For performance reasons, choose deleteMessages for batch deletion of multiple messages
     * Might throw SessionFetchError if there is a connection issue
     * @param to Session ID of recipient of the message
     * @param timestamp Timestamp of the message, returned from sendMessage; this is important and **must be exactly what's returned from sendMessage result**, otherwise clients which already received the message won't be able to delete it
     * @param hash Saved messageHash identifier of the message to delete, returned from sendMessage
     */
    deleteMessage: (args_0: {
        to: string;
        timestamp: number;
        hash: string;
    }) => Promise<void>;
    /**
     * Propogates unsend requests which Session clients use to delete messages locally. Alternatively, use deleteMessage for single message deletion
     * Might throw SessionFetchError if there is a connection issue
     * @param to Session ID of recipient of the message
     * @param timestamp Timestamp of the message, returned from sendMessage; this is important and **must be exactly what's returned from sendMessage result**, otherwise clients which already received the message won't be able to delete it
     * @param hashes Saved messages hashes identifiers of the message to delete, returned from sendMessage's messageHash
     */
    deleteMessages: (messages: {
        to: string;
        timestamp: number;
        hash: string;
    }[]) => Promise<void>;
    /**
     * Mark message as read and broadcast it to recipient
     * Might throw SessionFetchError if there is a connection issue
     * @param from Session ID of sender of the message
     * @param messagesTimestamps Array of timestamps of the messages to mark as read, returned from message constructor
     * @param readAt Timestamp when recipient of the message read it, defaults to current time. Does not seem to be used in current Session implementations
     */
    markMessagesAsRead: (args_0: {
        from: string;
        messagesTimestamps: number[];
        readAt?: number | undefined;
    }) => Promise<void>;
    /**
     * Show message typing indicator to recipient for 20 seconds or until hideTypingIndicator is called
     * Might throw SessionFetchError if there is a connection issue
     * @param conversation Session ID of conversation where typing indicator should appear
     */
    showTypingIndicator: (args_0: {
        conversation: string;
    }) => Promise<void>;
    /**
     * Hide message typing indicator from recipient
     * Might throw SessionFetchError if there is a connection issue
     * @param conversation Session ID of conversation where typing indicator should disappear
     */
    hideTypingIndicator: (args_0: {
        conversation: string;
    }) => Promise<void>;
    /**
     * Show notification that screenshot was taken in chat and broadcast it to other clients
     * Might throw SessionFetchError if there is a connection issue
     * @param conversation Session ID of conversation where screenshot was taken
     */
    notifyScreenshotTaken: (args_0: {
        conversation: string;
    }) => Promise<void>;
    /**
     * Show notification that attachment was downloaded in chat and broadcast it to other clients
     * Might throw SessionFetchError if there is a connection issue
     * @param conversation Session ID of conversation where attachment was downloaded
     * @param savedMessageTimestamp Timestamp of the message with attachment, returned from sendMessage
     */
    notifyMediaSaved: (args_0: {
        conversation: string;
        savedMessageTimestamp: number;
    }) => Promise<void>;
    /**
     * Accept conversation request from another Session ID
     * Might throw SessionFetchError if there is a connection issue
     * @param from Session ID of the sender of the conversation request
     */
    acceptConversationRequest: (args_0: {
        from: string;
    }) => Promise<void>;
    /**
     * Add emoji reaction to the message
     * Might throw SessionFetchError if there is a connection issue
     * @param messageTimestamp Timestamp of the message to react to, obtained from message object
     * @param messageAuthor Session ID of the author of the message to react to
     * @param emoji Emoji as string to add to reactions list. Any unicode character(s) are accepted, length is practically unlimited, but most clients will only display reaction if it's a single valid emoji.
     */
    addReaction: (args_0: {
        messageTimestamp: number;
        emoji: string;
        messageAuthor: string;
    }) => Promise<void>;
    /**
     * Remove emoji reaction from the message
     * Might throw SessionFetchError if there is a connection issue
     * @param messageTimestamp Timestamp of the message to remove react from, obtained from message object
     * @param messageAuthor Session ID of the author of the message to remove reaction from
     * @param emoji Emoji as string to add to reactions list. Any unicode character(s) are accepted, length is practically unlimited, but most clients will only display reaction if it's a single valid emoji
     */
    removeReaction: (args_0: {
        messageTimestamp: number;
        emoji: string;
        messageAuthor: string;
    }) => Promise<void>;
    protected _storeMessage: (args_0: {
        message: import("../messages/signal-message.js").RawMessage;
        data: import("../crypto/message-encrypt.js").EncryptAndWrapMessageResults;
    }) => Promise<string>;
    _request<Response, Body = any>({ type, body }: {
        type: RequestType;
        body: Body;
    }): Promise<Response>;
    /**
     * Advanced use. Returns profile object with display name and avatar of this instance
     * @returns Profile (for messages classes)
     */
    getMyProfile(): {
        displayName: string;
        avatar: {
            url: string;
            key: Uint8Array;
        } | undefined;
    };
    protected events: Map<EventName, EventCallback<EventName>[]>;
    on<E extends EventName>(eventName: E, callback: EventCallback<E>): void;
    off<E extends EventName>(eventName: E, callback: EventCallback<E>): void;
    addEventListener<E extends EventName>(eventName: E, callback: EventCallback<E>): void;
    removeEventListener<E extends EventName>(eventName: E, callback: EventCallback<E>): void;
    protected _emit<E extends EventName>(eventName: E, ...args: Parameters<EventCallback<E>>): void;
}
