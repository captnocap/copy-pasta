import _ from 'lodash';
import pRetry from 'p-retry';
import { SessionFetchError, SessionFetchErrorCode } from '@session.js/errors';
import { RequestType } from '@session.js/types/network/request';
export async function _storeMessage({ message, data }) {
    const messageToSelf = message.recipient === this.sessionID;
    let swarms = messageToSelf
        ? [await this.getOurSwarm()]
        : await this.getSwarmsFor(message.recipient);
    return await pRetry(async () => {
        let swarm;
        if (messageToSelf) {
            if (swarms.length) {
                swarm = _.sample(swarms);
            }
            else {
                swarm = _.sample(this.ourSwarms);
                this.ourSwarm = swarm;
            }
        }
        else {
            swarm = _.sample(swarms);
        }
        if (!swarm)
            throw new SessionFetchError({ code: SessionFetchErrorCode.NoSwarmsAvailable, message: 'No swarms available' });
        try {
            const { hash } = await this._request({
                type: RequestType.Store,
                body: {
                    swarm: swarm,
                    destination: message.recipient,
                    data64: data.data64,
                    ttl: data.ttl,
                    timestamp: data.networkTimestamp,
                    namespace: data.namespace,
                }
            });
            return hash;
        }
        catch (e) {
            if (e instanceof SessionFetchError && e.code === SessionFetchErrorCode.RetryWithOtherNode421Error) {
                swarms = swarms.filter(s => s !== swarm);
                this.ourSwarms = this.ourSwarms.filter(s => s !== swarm);
            }
            throw e;
        }
    }, {
        retries: 5,
        shouldRetry: (e) => e instanceof SessionFetchError && e.code === SessionFetchErrorCode.RetryWithOtherNode421Error
    });
}
