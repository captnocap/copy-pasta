import { decryptProfile } from '../profile/decrypt.js';
import { encryptProfile } from '../profile/encrypt.js';
import { SessionValidationError, SessionValidationErrorCode } from '@session.js/errors';
import { RequestType } from '@session.js/types/network/request';
import { SignalService } from '@session.js/types/signal-bindings';
import sodium from 'libsodium-wrappers-sumo';
export const PROFILE_IV_LENGTH = 12; // bytes
export const PROFILE_KEY_LENGTH = 32; // bytes
export const PROFILE_TAG_LENGTH = 128; // bits
export function serializeProfile(profile) {
    let signalILokiProfile;
    if (profile.avatar || profile.displayName) {
        signalILokiProfile = new SignalService.DataMessage.LokiProfile();
        if (profile.avatar && profile.avatar.url && profile.avatar.key.length) {
            signalILokiProfile.profilePicture = profile.avatar.url;
        }
        if (profile.displayName) {
            signalILokiProfile.displayName = profile.displayName;
        }
    }
    return {
        lokiProfile: signalILokiProfile,
        profileKey: profile.avatar?.key,
    };
}
export async function downloadAvatar(avatar) {
    const fileServerURL = 'http://filev2.getsession.org/file/';
    if (!avatar.url.startsWith(fileServerURL)) {
        throw new SessionValidationError({ code: SessionValidationErrorCode.InvalidAttachment, message: 'Avatar must be hosted on Session file server' });
    }
    const fileId = avatar.url.substring(fileServerURL.length);
    if (!/^\d+$/.test(fileId)) {
        throw new SessionValidationError({ code: SessionValidationErrorCode.InvalidAttachment, message: 'Invalid avatar file ID' });
    }
    const avatarFile = await this._request({
        type: RequestType.DownloadAttachment,
        body: {
            id: fileId,
        }
    });
    const decryptedAvatarImage = await decryptProfile(avatarFile, avatar.key);
    return decryptedAvatarImage;
}
export function deserializeProfile(signalILokiProfile) {
    const profile = {
        displayName: signalILokiProfile.lokiProfile?.displayName || '',
        avatar: (signalILokiProfile.lokiProfile?.profilePicture && signalILokiProfile.profileKey) ? {
            url: signalILokiProfile.lokiProfile.profilePicture,
            key: signalILokiProfile.profileKey
        } : undefined
    };
    return profile;
}
export async function uploadAvatar(avatar) {
    const profileKey = await sodium.randombytes_buf(32);
    const encryptedAvatar = await encryptProfile(avatar, profileKey);
    const uploadRequest = await this._request({
        type: RequestType.UploadAttachment,
        body: {
            data: encryptedAvatar
        }
    });
    return {
        profileKey,
        avatarPointer: uploadRequest.url
    };
}
