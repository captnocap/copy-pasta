import { SessionFetchError, SessionFetchErrorCode } from '@session.js/errors';
import { doSnodeBatchRequest } from '../batch-request';
import _ from 'lodash';
export async function storeMessage({ swarm, data64, destination, namespace, timestamp, ttl }) {
    const results = await storeOnNode.call(this, swarm, [{
            data: data64,
            namespace: namespace,
            pubkey: destination,
            timestamp: timestamp,
            ttl: ttl
        }], null);
    return { hash: results[0].body.hash };
}
/**
 * Send a 'store' request to the specified targetNode, using params as argument
 * @returns the Array of stored hashes if it is a success, or null
 */
async function storeOnNode(swarm, params, toDeleteOnSequence) {
    const subRequests = buildStoreRequests(params, toDeleteOnSequence);
    const result = await doSnodeBatchRequest.call(this, subRequests, { public_ip: swarm.ip, storage_port: Number(swarm.port), pubkey_ed25519: swarm.pubkey_ed25519, pubkey_x25519: swarm.pubkey_x25519 }, 4000, toDeleteOnSequence ? 'sequence' : 'batch');
    if (!result || !result.length) {
        throw new SessionFetchError({ code: SessionFetchErrorCode.InvalidResponse, message: 'Invalid result in storeOnMode' });
    }
    const firstResult = result[0];
    if (firstResult.code !== 200) {
        throw new SessionFetchError({ code: SessionFetchErrorCode.InvalidResponse, message: 'Invalid status code: ' + firstResult.code });
    }
    return result;
}
function buildStoreRequests(params, toDeleteOnSequence) {
    if (!toDeleteOnSequence || _.isEmpty(toDeleteOnSequence)) {
        return justStores(params);
    }
    return [...justStores(params), ...buildDeleteByHashesSubRequest(toDeleteOnSequence)];
}
function justStores(params) {
    return params.map(p => {
        return {
            method: 'store',
            params: p,
        };
    });
}
function buildDeleteByHashesSubRequest(params) {
    return [
        {
            method: 'delete',
            params,
        },
    ];
}
