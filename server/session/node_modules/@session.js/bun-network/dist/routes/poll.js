import { SessionFetchError, SessionFetchErrorCode } from '@session.js/errors';
import { SessionValidationError, SessionValidationErrorCode } from '@session.js/errors';
import { doSnodeBatchRequest } from '../batch-request';
import { SnodeNamespace, SnodeNamespaces } from '@session.js/types/namespaces';
import _ from 'lodash';
export async function poll({ swarm, namespaces }) {
    if (namespaces.length === 0) {
        throw new SessionValidationError({ code: SessionValidationErrorCode.InvalidNamespaces, message: `invalid number of retrieve namespace provided: ${namespaces.length}` });
    }
    if (namespaces.some(ns => ns.namespace === 'all'))
        throw new SessionValidationError({ code: SessionValidationErrorCode.UnsupportedFeature, message: 'namespace "all" is not supported yet' });
    const results = await pollSnode.call(this, { swarm, namespaces });
    if (results === null) {
        throw new SessionFetchError({ code: SessionFetchErrorCode.InvalidResponse, message: 'Polling failed' });
    }
    else {
        return { messages: results };
    }
}
export async function pollSnode({ swarm, namespaces }) {
    const request = await buildRetrieveRequest(namespaces);
    const results = await retrieveNextMessages.call(this, { public_ip: swarm.ip, storage_port: Number(swarm.port), pubkey_ed25519: swarm.pubkey_ed25519, pubkey_x25519: swarm.pubkey_x25519 }, request, namespaces.map(ns => ns.namespace));
    return results.map(({ messages, namespace }) => ({ namespace, messages: messages.messages }));
}
export const ERROR_CODE_NO_CONNECT = 'ENETUNREACH: No network connection.';
export async function retrieveNextMessages(targetNode, retrieveRequestsParams, namespaces) {
    const timeOutMs = 4 * 1000;
    const timeoutPromise = async () => new Promise(resolve => setTimeout(resolve, timeOutMs));
    const fetchPromise = async () => doSnodeBatchRequest.call(this, retrieveRequestsParams, targetNode, timeOutMs);
    const results = await Promise.race([timeoutPromise(), fetchPromise()]);
    if (!results || !_.isArray(results) || !results.length) {
        throw new SessionFetchError({ code: SessionFetchErrorCode.FetchFailed, message: `Could not connect to ${targetNode.public_ip}:${targetNode.storage_port}` });
    }
    // the +1 is to take care of the extra `expire` method added once user config is released
    if (results.length !== namespaces.length && results.length !== namespaces.length + 1) {
        throw new SessionFetchError({ code: SessionFetchErrorCode.InvalidResponse, message: 'Invalid number of results. Expected: ' + namespaces.length + ' or ' + (namespaces.length + 1) + ' but got: ' + results.length });
    }
    try {
        return results.map((result, index) => ({
            code: result.code,
            messages: result.body,
            namespace: namespaces[index],
        }));
    }
    catch (e) {
        throw new SessionFetchError({ code: SessionFetchErrorCode.InvalidResponse, message: 'Couldn\'t parse json of ' + targetNode.public_ip + ':' + targetNode.storage_port });
    }
}
async function buildRetrieveRequest(namespaces) {
    const maxSizeMap = SnodeNamespace.maxSizeMap(namespaces.map(ns => ns.namespace));
    const retrieveRequestsParams = await Promise.all(namespaces.map(async ({ namespace, pubkey, isOurPubkey, lastHash, signature }) => {
        const foundMaxSize = maxSizeMap.find(m => m.namespace === namespace)?.maxSize;
        const retrieveParam = {
            pubkey: pubkey,
            lastHash: lastHash || '',
            namespace,
            timestamp: signature.timestamp,
            maxSize: foundMaxSize,
        };
        if (namespace === SnodeNamespaces.ClosedGroupMessage) {
            if (isOurPubkey || !pubkey.startsWith('05')) {
                throw new Error('SnodeNamespace `-10` (ClosedGroupMessage) can only be used to retrieve messages from a legacy closed group (prefix 05). If you\'re developer trying to poll user\'s closed chat groups and other groups, you\'re probably looking for SnodeNamespace `5` (UserGroups)');
            }
            const retrieveLegacyClosedGroup = {
                ...retrieveParam,
                namespace,
            };
            const retrieveParamsLegacy = {
                method: 'retrieve',
                params: _.omit(retrieveLegacyClosedGroup, 'timestamp'), // if we give a timestamp, a signature will be required by the service node, and we don't want to provide one as this is an unauthenticated namespace
            };
            return retrieveParamsLegacy;
        }
        // all legacy closed group retrieves are unauthenticated and run above.
        // if we get here, this can only be a retrieve for our own swarm, which must be authenticated
        if (!SnodeNamespace.isUserConfigNamespace(namespace) &&
            namespace !== SnodeNamespaces.UserMessages) {
            throw new SessionValidationError({ code: SessionValidationErrorCode.NotZeroNamespaceNotLegacyClosedGroup, message: 'Namespace should be 0 when polling legacy closed group, got' + namespace });
        }
        if (!isOurPubkey) {
            throw new SessionValidationError({ code: SessionValidationErrorCode.NotOurPubkeyNotLegacyClosedGroup, message: 'While polling for new messages that are not legacy closed group, pubkey can only be ours' });
        }
        const retrieve = {
            method: 'retrieve',
            params: {
                ...retrieveParam,
                namespace: retrieveParam.namespace,
                ...signature,
                pubkey_ed25519: signature.pubkeyEd25519
            }
        };
        return retrieve;
    }));
    return retrieveRequestsParams;
}
