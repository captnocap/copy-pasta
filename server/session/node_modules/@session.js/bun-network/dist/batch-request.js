import _ from 'lodash';
import { snodeRpc } from './session-rpc';
import { MAX_SUBREQUESTS_COUNT, } from './snode-request-types';
import { SessionRuntimeError, SessionRuntimeErrorCode } from '@session.js/errors';
import { SessionFetchError, SessionFetchErrorCode } from '@session.js/errors';
/**
 * This is the equivalent to the batch send on sogs. The target node runs each sub request and returns a list of all the sub status and bodies.
 * If the global status code is not 200, an exception is thrown.
 * The body is already parsed from json and is enforced to be an Array of at least one element
 * @param subRequests the list of requests to do
 * @param targetNode the node to do the request to, once all the onion routing is done
 * @param timeout the timeout at which we should cancel this request.
 * @param method can be either batch or sequence. A batch call will run all calls even if one of them fails. A sequence call will stop as soon as the first one fails
 */
export async function doSnodeBatchRequest(subRequests, targetNode, timeout, method = 'batch') {
    if (subRequests.length > MAX_SUBREQUESTS_COUNT) {
        throw new SessionRuntimeError({
            code: SessionRuntimeErrorCode.Generic,
            message: `batch subRequests count cannot be more than ${MAX_SUBREQUESTS_COUNT}. Got ${subRequests.length}`
        });
    }
    const result = await snodeRpc.call(this, {
        method,
        params: { requests: subRequests },
        targetNode,
        timeout,
    });
    if (!result) {
        throw new SessionFetchError({
            code: SessionFetchErrorCode.FetchFailed,
            message: `Couldn't connect to ${targetNode.public_ip}:${targetNode.storage_port}`
        });
    }
    const decoded = decodeBatchRequest(result);
    // if (decoded?.length) {
    //   for (let index = 0; index < decoded.length; index++) {
    // const resultRow = decoded[index]
    // // eslint-disable-next-line no-await-in-loop
    // await processOnionRequestErrorAtDestination({
    //   statusCode: resultRow.code,
    //   body: JSON.stringify(resultRow.body),
    //   associatedWith: associatedWith || undefined,
    //   destinationSnodeEd25519: targetNode.pubkey_ed25519,
    // })
    //   }
    // }
    return decoded;
}
/**
 * Make sure the global batch status code is 200, parse the content as json and return it
 */
function decodeBatchRequest(snodeResponse) {
    if (snodeResponse.status !== 200) {
        throw new SessionRuntimeError({
            code: SessionRuntimeErrorCode.Generic,
            message: `decodeBatchRequest invalid status code: ${snodeResponse.status}`
        });
    }
    const parsed = JSON.parse(snodeResponse.body);
    if (!_.isArray(parsed.results)) {
        throw new SessionRuntimeError({
            code: SessionRuntimeErrorCode.Generic,
            message: 'decodeBatchRequest results is not an array'
        });
    }
    if (!parsed.results.length) {
        throw new SessionRuntimeError({
            code: SessionRuntimeErrorCode.Generic,
            message: 'decodeBatchRequest results an empty array'
        });
    }
    return parsed.results;
}
